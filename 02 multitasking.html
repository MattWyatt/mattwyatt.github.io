<!DOCTYPE html>
<html>
<head>
	<title>the archives</title>

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="css/styles.css">
	<link rel="stylesheet" href="css/fonts.css">
	<link rel="stylesheet" href="css/code.css">
</head>
<body>
	<div id="aesthetics">
		<canvas id="mainCanvas"></canvas>
	</div>
	<div id="content">
		<a id="sidebarButton"><h1>menu</h1></a>
		<div id="sidebar">
			<h1>matt wyatt</h1>
			<ul>
				<li><a href="index.html">about</a></li>
				<li><a href="work.html">work</a></li>
				<li><a href="diary.html">diary</a></li>
				<li><a href="mailto:mwyatt1000@gmail.com">contact</a></li>
			</ul>
		</div>
		<div class='letter'><h1><a href="02 multitasking.html">linux-based multitasking</a></h1>

<h3>this made me understand std::thread</h3>

<p>For whatever reason, I've always fancied the idea of building a process manager. I have indeed built one, and her name is <a href="https://github.com/MattWyatt/sybil-process.manager">Sybil</a>. Sybil, however, was thrown together for a competition. When creating her, I did a lot of things that would probably be considered bad practice. Regardless, she works well. One of the largest problems I encountered when writing her, however, was the recording of output from processes. I got it to work, but, until looking into it further and writing this article, I had no idea how I did it. After quite the bit of research, and an epiphany regarding how multithreading in C++ works, I've written what appears to be a very coherent process wrapper.</p>

<h2>sybil's predicament</h2>

<p>When writing Sybil, I figured I'd just spawn the process and then write its output to a buffer. Sounds easy, right? Well, in terms of code required, it is. Simply spawn the process, redirect its input to a pipe, and read the pipe. The problem, however? <code>read()</code> is a blocking call. I could only retrieve the output once the process spawned was over. That's almost completely useless for something like a server where (hopefully) it would not have to end. Sybil needed to be able to report a <em>continuous</em> stream of output, even if the process hadn't finished yet.</p>

<h2>sybil's solution</h2>

<p>Clearly, if <code>read()</code> blocked the current thread, then I'd have to do it in a separate thread. Fair enough, I figured I knew how to write a multithreaded application in C++. I didn't. I had gotten the hang of creating a thread, that wasn't too hard.</p>

<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * listen for whatever reason this works, so don&#39;t touch it.</span>
<span class="cm"> * if you pass the sybling as a reference, instead of as the object itself,</span>
<span class="cm"> * then nothing gets deleted</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sybling</span><span class="o">::</span><span class="n">read_thread</span><span class="p">(</span><span class="n">sybling</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">reader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sybling</span><span class="o">::</span><span class="n">read_process</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
    <span class="n">reader</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    <span class="n">o</span><span class="o">-&gt;</span><span class="n">_read_thread_running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>By the comments, it's clear that I had almost no idea what I was doing. Any experienced C++ developer, at this point, would probably shout, "why are you detaching the thread?!?!?!". Their question would be well-placed. Why was I detaching the thread? This is where I admit to what is probably my dumbest mistake in programming yet. For whatever reason, I thought that creating a thread didn't spawn it simultaneously. I thought that after creating a <code>std::thread</code>, you had to call either <code>join()</code> or <code>detach()</code> to make it do anything. <code>join()</code> seemed like a completely useless method to me. Why would I want to create a different thread just to have it block the main one? In hindsight, I'm not really sure how I came to this conclusion; the C++ website itself shows the behavior of threads to, very clearly, work unlike this. Regardless, this <em>did</em> indeed work. I did not know why, and I knew there was a better way that was incomprehensible to me.</p>

<h2>an updated solution</h2>

<p>After I <em>actually</em> understood how thread objects work, I decided to rewrite a new and updated process handler proof-of-concept. Among the minor changes: the <code>process</code> class stores a static vector to hold all the reader threads created, <code>exit_processes()</code> must be called to join all the reader threads to ensure they're close successfully, and simple functions are supported as well. The methods for actually creating the process and redirecting the input remain the same as Sybil's methods. The read thread itself, however, differs beautifully.</p>

<div class="codehilite"><pre><span></span><code><span class="cm">/* create the read thread and push it back */</span>
<span class="n">_readers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
    <span class="cm">/* block and read every character from stdin individually</span>
<span class="cm">     * then push it back to the output buffer */</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">_pipe</span><span class="p">.</span><span class="n">oread</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_output</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}));</span>
</code></pre></div>

<p>The following code block is heavily documented, and shows exactly the process of creating a process. (heh)</p>

<div class="codehilite"><pre><span></span><code><span class="cm">/* create a process object with a function*/</span>
<span class="n">process</span> <span class="nf">p</span><span class="p">([]()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello, multitasking!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>

<span class="cm">/* begin execution </span>
<span class="cm"> * the process object will store the task&#39;s output</span>
<span class="cm"> * even if the task is not completed yet */</span>
<span class="n">p</span><span class="p">.</span><span class="n">execute</span><span class="p">();</span>


<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;process created!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="cm">/* perform some task in the frontend that may take a bit */</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;working on other things for a bit...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;done working. earlier process is finished by now.</span><span class="se">\n</span><span class="s">output: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="cm">/* grab the output of the process, even though it may not be over yet */</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">output</span><span class="p">();</span>

<span class="cm">/* ensure that before we exit, we exit all the created processes */</span>
<span class="n">process</span><span class="o">::</span><span class="n">exit_processes</span><span class="p">();</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<p>The full project and documentation (which is just comments) can be found <a href="https://github.com/MattWyatt/multitasking-concept">here</a></p>
</div>
	</div>
</body>
<script src="js/rough.min.js"></script>
<script src="js/menu.js"></script>
<script src="js/drawer.js"></script>
</html>
